project 
"
<Project Sdk="Microsoft.NET.Sdk.Web">

  <PropertyGroup>
    <TargetFramework>net8.0</TargetFramework>
    <Nullable>enable</Nullable>
    <ImplicitUsings>enable</ImplicitUsings>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="Microsoft.Extensions.Caching.StackExchangeRedis" Version="8.0.10" />
    <PackageReference Include="Newtonsoft.Json" Version="13.0.3" />
    <PackageReference Include="StackExchange.Redis" Version="2.8.16" />
    <PackageReference Include="Swashbuckle.AspNetCore" Version="6.4.0" />
  </ItemGroup>

  <ItemGroup>
    <ProjectReference Include="..\GecolPro.DCBSystem\GecolPro.DCBSystem.csproj" />
    <ProjectReference Include="..\GecolPro.GecolSystem\GecolPro.GecolSystem.csproj" />
    <ProjectReference Include="..\GecolPro.Models\GecolPro.Models.csproj" />
    <ProjectReference Include="..\GecolPro.Services\GecolPro.Services.csproj" />
  </ItemGroup>

</Project>

"

appsettings.json
"
{
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft.AspNetCore": "Warning"
    }
  },

  "AuthHeaderOfDCB": {
    "username": "SMSC_NS_DCB",
    "password": "S3IS9C8D_HI6P4S5",
    "url": "http://172.16.18.165:8223/ocswebservices/services/WebServicesSoapLibya"
  },


  "AuthHeaderOfGecol": {
    "username": "AG0502",
    "password": "1234567891012",
    "url": "http://160.19.103.138:8080/xmlvend/xmlvend.wsdl",
    "eandeviceId": "0000000000001",
    "genericdeviceId": "0000000000001"

  },

  "AllowedHosts": "*",
  "Urls": "http://localhost:5015"
}
"

Program.cs
"
using GecolPro.WebApi.UssdService;
using GecolPro.WebApi.Interfaces;
using GecolPro.WebApi.BusinessRules;

using GecolPro.Services;
using GecolPro.Services.IServices;

using GecolPro.GecolSystem;
using GecolPro.DCBSystem;

using GecolPro.Models.DCB;
using GecolPro.Models.Gecol;


var builder = WebApplication.CreateBuilder(args);

// Add services to the container.

builder.Services.AddControllers();
// Learn more about configuring Swagger/OpenAPI at https://aka.ms/aspnetcore/swashbuckle
builder.Services.AddEndpointsApiExplorer();
builder.Services.AddSwaggerGen();

builder.Services.Configure<AuthHeader>(builder.Configuration.GetSection("AuthHeaderOfDCB"));
builder.Services.Configure<AuthCred>(builder.Configuration.GetSection("AuthHeaderOfGecol"));





builder.Services.AddScoped<IDcbServices, DcbServices>();
builder.Services.AddScoped<IGecolServices, GecolServices>();


builder.Services.AddScoped<IUssdConverter, UssdConverter>();
builder.Services.AddScoped<IResponses, Responses>();
builder.Services.AddScoped<ILoggers,Loggers>();
builder.Services.AddScoped<ISendMessage, SendMessage>();
builder.Services.AddScoped<IBlackListFun,BlackListFun>();
builder.Services.AddScoped<IMenus,Menus>();
builder.Services.AddScoped<IUssdProcessV1, UssdProcessV1>();






var app = builder.Build();

// Configure the HTTP request pipeline.
if (app.Environment.IsDevelopment())
{
    app.UseSwagger();
    app.UseSwaggerUI();
}

app.UseHttpsRedirection();

app.UseAuthorization();

app.MapControllers();

app.Run();
"

UssdGecolController
"

using Microsoft.AspNetCore.Mvc;
using System.Text;
using GecolPro.Services.IServices;


//using static Microsoft.EntityFrameworkCore.DbLoggerCategory.Database;

using GecolPro.WebApi.BusinessRules;
using static GecolPro.Models.Models.MultiRequestUSSD;
using GecolPro.Models.Models;
using GecolPro.Services;
using GecolPro.WebApi.Interfaces;

namespace GecolPro.WebApi.Controllers
{
    [ApiController]

    public class UssdGecolController : ControllerBase
    {

        private ILoggers _loggerG;
        private IUssdConverter _ussdConverter;
        private IResponses _responses;
        private IUssdProcessV1 _ussdProcess;



        private MultiRequest multiRequestRE = new MultiRequest();
        private readonly string contentType = "text/xml";
        //private ServiceProcess.SendMessage sendMessage = new ServiceProcess.SendMessage();


  




        public UssdGecolController(IUssdConverter ussdConverter, IResponses responses, ILoggers loggerG, IUssdProcessV1 ussdProcess)
        {
            _ussdConverter = ussdConverter;
            _responses = responses;
            _loggerG = loggerG;
            _ussdProcess = ussdProcess;
        }


        private async Task<ContentResult> GetResponseV1(string xmlContent, string lang)
        {
                        ContentResult response = new ContentResult();

            MultiRequestUSSD.MultiRequest multiRequest = await _ussdConverter.ConverterFaster(xmlContent);


            MultiResponseUSSD multiResponse = await _ussdProcess.ServiceProcessing(multiRequest, lang);

            await _loggerG.LogUssdTransAsync($"{xmlContent}");




            if (multiResponse.ResponseCode == 0 || multiResponse.ResponseCode == null)
            {
                string respContetn = _responses.Resp(multiResponse);

                await _loggerG.LogUssdTransAsync($"{respContetn}");

                response = new ContentResult
                {
                    ContentType = contentType,
                    Content = respContetn,
                    StatusCode = 200
                };
                return response;

            }
            else
            {
                string respContetn = _responses.Fault_Response(multiResponse);

                await _loggerG.LogDcbTransAsync($"{respContetn}");

                response = new ContentResult
                {
                    ContentType = contentType,
                    Content = respContetn,
                    StatusCode = 400
                };
                return response;
            }
        }




        #region API Region 

        // Version 1

        //English

        [HttpPost]
        [Consumes("text/xml")]
        [Route("api/[Controller]/creditVendReq/V1/En")]
        public async Task<ContentResult> PostV1En()
        {
            using (StreamReader reader = new StreamReader(Request.Body, Encoding.UTF8))
            {
                ContentResult response = new ContentResult();

                string xmlContent = await reader.ReadToEndAsync();

                response = await GetResponseV1(xmlContent, "En");

                return response;
            }

        }

        //Arabic

        [HttpPost]
        [Consumes("text/xml")]
        [Route("api/[Controller]/creditVendReq/V1/Ar")]
        public async Task<ContentResult> PostV1Ar()
        {
            using (StreamReader reader = new StreamReader(Request.Body, Encoding.UTF8))
            {
                ContentResult response = new ContentResult();

                string xmlContent = await reader.ReadToEndAsync();

                MultiRequest multiRequest = await _ussdConverter.ConverterFaster(xmlContent);

                response = await GetResponseV1(xmlContent, "Ar");



                return response;
            }
        }
        #endregion

    }
}
"

UssdProcessV1
"
using System.Globalization;
using Newtonsoft.Json;

//Models

using GecolPro.Models.Models;
using GecolPro.Models.DCB;
using GecolPro.Models.Gecol;


using static GecolPro.Models.Models.MultiRequestUSSD;


// Class Library
using GecolPro.DCBSystem;
using GecolPro.GecolSystem;
using GecolPro.Services.IServices;
using GecolPro.WebApi.Interfaces;






namespace GecolPro.WebApi.BusinessRules
{
    public class UssdProcessV1 : IUssdProcessV1
    {

        private readonly AuthHeader _authHeader;

        private Random random = new Random();

        private ILoggers _loggerG ;
        private MsgContent msgContentResult = new MsgContent();
        private SubProService subProService = new SubProService();
        private IDcbServices? _dcbServices;
        private IGecolServices? _gecolServices;
        private IMenus? _menus;
        private ISendMessage? _sendMessage;



        //
        private const string logPrefix = "LynaGclsys";

        //
        private string conversationId => subProService.ConversationID;
        private string transactionID => subProService.TransactionID;


        public UssdProcessV1(
            IGecolServices  gecolServices , 
            IDcbServices?   dcbServices,
            ILoggers        loggerG,
            IMenus          menus,
            ISendMessage    sendMessage,
            IConfiguration _config)
        {
            _dcbServices = dcbServices;
            _gecolServices = gecolServices;
            _loggerG = loggerG;
            _menus = menus;
            _sendMessage = sendMessage;
            _authHeader = new AuthHeader()
            {
                Username = _config.GetValue<string>("AuthHeaderOfDCB:username"),
                Password = _config.GetValue<string>("AuthHeaderOfDCB:password"),
                Url      = _config.GetValue<string>("AuthHeaderOfDCB:url")
            };
        }

        private enum RespActions
        {
            request,
            end
        }
        private enum Respresponse
        {
            True,
            False
        }





        /*Provide USSD and SMS Message Reply :

 */

        private async Task<MsgContent> MenuReader(SubProService subProService, string Lang)
        {
            try
            {
                DcbSystemResponse subProServiceResp = await _dcbServices.QryUserBasicBalOp(subProService.MSISDN);

                if (subProServiceResp.IsSuccessStatusCode)
                {

                    var BalanceValue = subProServiceResp.Response;

                    List<string> outputs = new List<string>();

                    outputs.Add(subProService.MeterNumber);
                    outputs.Add(subProService.Amount.ToString());
                    outputs.Add(subProService.MSISDN);
                    outputs.Add(BalanceValue);

                    msgContentResult = await _menus.SuccessResponseAsync(outputs, Lang);
                    return (msgContentResult);

                }
                else
                {
                    msgContentResult = await _menus.UnderMaintenance_Billing(subProServiceResp.StatusCode, Lang);

                    return (msgContentResult);
                }
            }
            catch (Exception ex)
            {
                await ExceptionLogs(ex);

                return new MsgContent()
                {
                    UssdCont = "Error performing request Unknown Error"
                };
            }
        }




        /*Chech if Msisdn Blocked or Not :
         */

        private async Task<bool> BlackListMsisdn(string msisdn)
        {
            try
            {

                string baseDirectory = AppDomain.CurrentDomain.BaseDirectory;
                string jsonFilePath = Path.Combine(baseDirectory, "BlackListMsisdn.json");

                if (!File.Exists(jsonFilePath))
                {
                    await _loggerG.LogInfoAsync($"{logPrefix}|xxx|BlackList_File_Not_Found|{conversationId}|Service Connected");
                    return false;
                }

                string json = await File.ReadAllTextAsync(jsonFilePath);

                if (string.IsNullOrWhiteSpace(json))
                {
                    await _loggerG.LogInfoAsync($"{logPrefix}|xxx|BlackList_Empty_File|{conversationId}|Service Connected");
                    return false;
                }

                string[]? blackList = JsonConvert.DeserializeObject<string[]>(json);

                if (blackList != null && blackList.Any(x => x.StartsWith(msisdn)))
                {
                    await _loggerG.LogInfoAsync($"{logPrefix}|xxx|Msisdn_Blocked|{conversationId}|Service Connected");
                    return true;
                }

                return false;
            }
            catch (Exception ex)
            {
                await ExceptionLogs(ex);
                return false;
            }

        }




        /*Chech if Gecol System Reachable or Not :
         
        */

        public async Task<bool> CheckServiceExist()
        {
            try
            {
                await _loggerG.LogInfoAsync($"{logPrefix}==>|Req_GecolCheck|{conversationId}|Check Service Connectivity");

                GecolSystemResponse loginOp = await _gecolServices.LoginReqOp();

                if (loginOp.IsSuccessStatusCode)
                {
                    await _loggerG.LogInfoAsync($"{logPrefix}|<==|Rsp_GecolCheck|{conversationId}|Service Connected");
                    return true;
                }

                await _loggerG.LogInfoAsync($"{logPrefix}|<==|Rsp_GecolCheck|{conversationId}|Service Not Connected");
                return false;


            }
            catch (Exception ex)
            {
                await ExceptionLogs(ex);
                return false;
            }


        }




        /* API to check if Tirmenated Meter in Gecol Avaiable or not also check if Meter Working :
        //
        // Chech if Meter Exist or not :
        //
        // 1. check first in DataBase.
        //
        // 2. if not exist in DB check in Gecol by API.
        //
        // 3. reply with not exist if not right meter. 
        //
        */

        private async Task<bool> CheckMeterExist(string MeterNumber)
        {
            try
            {

                string meterNumber = subProService.MeterNumber;

                await _loggerG.LogInfoAsync($"{logPrefix}==>|Req_GecolMeter|{conversationId}|Check The Meter|{meterNumber}");

                // Query in DB
                // Uncomment and implement DB query logic here
                // if (condition)
                // {
                // }
                // else if (otherCondition)
                // {
                // }

                GecolSystemResponse gecolSystem = await _gecolServices.ConfirmCustomerOp(MeterNumber);

                if (gecolSystem.IsSuccessStatusCode)
                {
                    await _loggerG.LogInfoAsync($"{logPrefix}<==|Rsp_GecolMeter|{conversationId}|The Meter Connected|{meterNumber}");
                    return true;
                }

                await _loggerG.LogInfoAsync($"{logPrefix}<==|Rsp_GecolMeter|{conversationId}|The Meter Number Not Exist or has Issue|{meterNumber}");
                return false;
            }
            catch (Exception ex)
            {
                await ExceptionLogs(ex);
                return false;
            }



        }




        /* Charge balance from Billing :
        * 
        * 1. if charging Success reply with true.
        *
        * 2. if charging Failed reply with false.
        *
         */

        private async Task<TokenOrError> ProcessChargeByDCB(SubProService subProService)
        {

            try
            {

                string msisdn = subProService.MSISDN;
                int amount = subProService.Amount;

                await _loggerG.LogInfoAsync($"{logPrefix}|==>|Req_BillingSys|{conversationId}|{msisdn}|{amount}");

                DcbSystemResponse subProServiceResp = await _dcbServices.DirectDebitUnitOp(conversationId, msisdn, amount);

                await _loggerG.LogInfoAsync($"{logPrefix}|<==|Rsq_BillingSys|{conversationId}|{msisdn}|{amount}|{subProServiceResp.IsSuccessStatusCode}|{subProServiceResp.Response}");

                if (subProServiceResp.IsSuccessStatusCode)
                {
                    //here ConncetionString to saveing in DB in success case : 
                    return new TokenOrError
                    {
                        TknOrErr = subProServiceResp.Response,
                        Status = true
                    };
                }

                //*here ConncetionString to saveing in DB in Failed case :

                return new TokenOrError
                {
                    TknOrErr = subProServiceResp.Response,
                    Status = false
                };


            }
            catch (Exception ex)
            {
                await ExceptionLogs(ex);
                return new TokenOrError
                {
                    TknOrErr = ex.Message,
                    Status = false
                };
            }
        }




        /* Rollback balance with Billing :
        * 
        * 1. if charging Success reply with true.
        *
        * 2. if charging Failed reply with false.
        *
         */

        private async Task<TokenOrError> ProcessRollBackDCB(SubProService subProService)
        {

            try
            {

                string msisdn = subProService.MSISDN;
                int amount = subProService.Amount;

                await _loggerG.LogInfoAsync($"{logPrefix}|==>|Req_RollBackDCB|{conversationId}|{msisdn}|{amount}");

                DcbSystemResponse subProServiceResp = await _dcbServices.DebitRollbackOp(conversationId, subProService.TransactionID, msisdn, amount);

                await _loggerG.LogInfoAsync($"{logPrefix}|<==|Rsq_RollBackDCB|{conversationId}|{msisdn}|{amount}|{subProServiceResp.IsSuccessStatusCode}|{subProServiceResp.Response}");

                if (subProServiceResp.IsSuccessStatusCode)
                {
                    //here ConncetionString to saveing in DB in success case : 
                    return new TokenOrError
                    {
                        TknOrErr = subProServiceResp.Response,
                        Status = true
                    };
                }

                //*here ConncetionString to saveing in DB in Failed case :

                return new TokenOrError
                {
                    TknOrErr = subProServiceResp.Response,
                    Status = false
                };


            }
            catch (Exception ex)
            {
                await ExceptionLogs(ex);
                return new TokenOrError
                {
                    TknOrErr = ex.Message,
                    Status = false
                };
            }
        }



        /* Order Token From GECOL :
* 
* 1. if token Success reply with true.
*
* 2. if token Failed reply with false.
*
 */

        private async Task<TokenOrError> ProcessTokenFromGecol(SubProService subProService)
        {

            try
            {
                string msisdn = subProService.MSISDN;
                int amount = subProService.Amount;
                string uniqeNumber = subProService.UniqueNumber;

                await _loggerG.LogInfoAsync($"{logPrefix}|==>|Req_GecolVnSys|{conversationId}|{msisdn}|{amount}");

                var subProServiceResp = await _gecolServices.CreditVendOp(subProService.MeterNumber, uniqeNumber, amount);

                await _loggerG.LogInfoAsync($"{logPrefix}|<==|Rsq_GecolVnSys|{conversationId}|{msisdn}|{amount}|{subProServiceResp.IsSuccessStatusCode}|{subProServiceResp.Response}|{uniqeNumber}");


                /*
                //if (subProServiceResp.Status)
                //{
                //    return (subProServiceResp.Response, subProServiceResp.Status);
                //}
                //else
                //{
                //    return (subProServiceResp.Response, subProServiceResp.Status);
                //}
                */


                if (subProServiceResp.IsSuccessStatusCode)
                {
                    /*here ConncetionString to saveing in DB in success case : 
                    */

                    return new TokenOrError()
                    {
                        TknOrErr = subProServiceResp.Response,
                        Status = true

                    };


                }
                /*here ConncetionString to saveing in DB in Failed case :
                    */

                //msgContentResult = await Menus.UnderMaintenance_Billing(subProServiceResp.StatusCode);

                return new TokenOrError
                {
                    TknOrErr = subProServiceResp.Response,
                    Status = false

                };


            }
            catch (Exception ex)
            {
                await ExceptionLogs(ex);
                return new TokenOrError()
                {
                    TknOrErr = ex.Message,
                    Status = false
                };
            }

        }




        /* Send SMS API to SMPP Client  :
        */

        public async Task SendGecolMessage(string? sender, string receiver, string message)
        {
            try
            {
                HttpClient client = new HttpClient();
                string msisdn = subProService.MSISDN;

                var request = new HttpRequestMessage(HttpMethod.Post, "http://172.16.31.17:8086/api/Messages");

                SmsMessage jsonObject = new()
                {
                    Sender = "2188997772",//sender ?? "2188997772",
                    Receiver = receiver,
                    Message = message
                };

                var content = new StringContent(JsonConvert.SerializeObject(jsonObject), null /*System.Text.Encoding.UTF8*/, "application/json");
                request.Content = content;

                var response = await client.SendAsync(request);

                await _loggerG.LogInfoAsync($"{logPrefix}|==>|Req_SMSCSystem|Submet|To|{msisdn}");

                response.EnsureSuccessStatusCode();
                var messageResponse = await response.Content.ReadAsStringAsync();

                await _loggerG.LogInfoAsync($"{logPrefix}|<==|Rsp_SMSCSystem|Response|{messageResponse}");
            }
            catch (Exception ex)
            {
                await ExceptionLogs(ex);
            }
        }




        /* Use this Model for Collect USSD, DCB & GECOL Parameters in one Object:
       */

        private SubProService CreateSubProService(MultiRequest multiRequest, string sessionId)
        {
            string[] Para = multiRequest.USSDRequestString.Split('#');

            if (Para.Length < 2)
            {
                throw new ArgumentException("The USSD request string does not contain enough parameters.");
            }

            //
            //check if the amount value if int or not
            //
            int amount = 0;
            if (int.TryParse(Para[1], out int result))
            {
                amount = result;
            }

            SubProService subProService = new()
            {
                ConversationID = sessionId,

                MSISDN = multiRequest.MSISDN,

                DateTimeReq = DateTime.Now.ToString("yyyy-MM-dd_HH:mm:ss"),

                MeterNumber = Para[0],

                Amount = amount
            };

            return subProService;
        }




        /*Chech Exception Logs :
        */

        private async Task ExceptionLogs(Exception ex)
        {
            await _loggerG.LogDebugAsync(
                  $"excp" +
                  $"\n{subProService.ConversationID}|{ex.Message}" +
                  $"\n{subProService.ConversationID}|{ex.InnerException}" +
                  $"\n{subProService.ConversationID}|{ex.StackTrace.ToString()}"
                  );
        }




        /* Main Class (Service Start here)
         */

        public async Task<MultiResponseUSSD> ServiceProcessing(MultiRequest multiRequest, string Lang)
        {
            TokenOrError TokenOrder;

            /* Service start here

             the logic here use two condtions ,
            
             - Generate Sesstion ID : for Subscriber Request
            
             - Check Meter DBs : Check Meter in database if exist  return with true
            
             - Check Meter API : if not in DB check by API if exist add to DB and return with true
            
             - if not exist reply with false
            */



            /* Generate Sesstion ID :

            */
            string TransIDms = DateTime.Now.ToString("fff");

            string sessionId = DateTime.Now.ToString($"yyyyMMddHHmmss{TransIDms}");

            if (DateTime.TryParseExact(multiRequest.TransactionTime, "M/d/yyyy h:mm:ss tt", CultureInfo.InvariantCulture, DateTimeStyles.None, out DateTime parsedDate))
            {
                // Format the DateTime object into the desired format
                sessionId = parsedDate.ToString("yyyyMMddHHmmss") + TransIDms;
            }




            /* Logger for start Sesstion :
             */

            await _loggerG.LogInfoAsync($"UssdSystem|==>|Req_{logPrefix}|Start|Session_Id |{sessionId}");





            /* Use this Model for Collect USSD, DCB & GECOL Parameters in one Object:
            */

            subProService = CreateSubProService(multiRequest, sessionId);




            /* Check BlackList :
 */

            if (await BlackListMsisdn(multiRequest.MSISDN))
            {
                msgContentResult = await _menus.BlockedResponseAsync(Lang);

                return new MultiResponseUSSD
                {
                    TransactionId = multiRequest.TransactionId,
                    TransactionTime = DateTime.Now.ToString("yyyyMMddTHH:mm:ss"),
                    MSISDN = multiRequest.MSISDN,
                    USSDServiceCode = "0",
                    USSDResponseString = msgContentResult.UssdCont,
                    Action = RespActions.end.ToString(),
                    ResponseCode = 9988
                };
            }




            /* API to check if Gecol API Service Avaiable or not also check if our account Working:
             */

            if (await CheckServiceExist())
            {
                //
                //

                /* API to check if Tirmenated Meter in Gecol Avaiable or not also check if Meter Working:
                */

                if (await CheckMeterExist(subProService.MeterNumber))
                {
                    //
                    //

                    /* Create Ussd and SMS Contents:*/

                    try
                    {
                        TokenOrder = await ProcessTokenFromGecol(subProService);

                        string gecolToken = TokenOrder.TknOrErr;



                        if (TokenOrder.Status)
                        {
                            
                            //TokenOrder = await ProcessChargeByDCB(subProService);
                            
                            //subProService.TransactionID = TokenOrder.TknOrErr;

                            //
                            TokenOrder.Status = true;

                            if (TokenOrder.Status)
                            {
                                List<string> outputs = new()
                                {
                                    subProService.MeterNumber,
                                    subProService.Amount.ToString(),
                                    gecolToken,
                                    subProService.UniqueNumber
                                };

                                msgContentResult = await _menus.SuccessResponseAsync(outputs, Lang);

                                if (!string.IsNullOrEmpty(msgContentResult.MessageCont))
                                {
                                    _sendMessage.SendGecolMessage(null, subProService.MSISDN, msgContentResult.MessageCont, subProService.ConversationID);
                                }
                                else
                                {
                                    msgContentResult = await _menus.UnderMaintenance_Billing(TokenOrder.TknOrErr, Lang);
                                }
                            }
                            else
                            {
                                var tk = ProcessRollBackDCB(subProService);


                                msgContentResult = await _menus.UnderMaintenance_Billing(TokenOrder.TknOrErr, Lang);

                            }
                            

                        }
                        else
                        {
                            msgContentResult = await _menus.UnderMaintenance_Gecol(TokenOrder.TknOrErr, Lang);
                        }


                    }
                    catch (Exception ex)
                    {
                        msgContentResult.UssdCont = ex.Message;
                        msgContentResult.MessageCont = ex.Message;
                    }
                }
                else
                {
                    msgContentResult = await _menus.UnderMaintenance_Gecol("VD.01010018", Lang);
                }
            }
            else
            {
                msgContentResult = await _menus.UnderMaintenance_Gecol(default, Lang);
            }

            // Generate USSD Response

            await _loggerG.LogInfoAsync($"UssdSystem|<==|Rsp_{logPrefix}|Close|Session_Id |{sessionId}");

            var multiResponse = new MultiResponseUSSD()
            {
                TransactionId = multiRequest.TransactionId,
                TransactionTime = DateTime.Now.ToString("yyyyMMddTHH:mm:ss"),
                MSISDN = multiRequest.MSISDN,
                USSDServiceCode = "0",
                USSDResponseString = msgContentResult.UssdCont,
                Action = RespActions.end.ToString(),
            };

            return multiResponse;
        }
    }
}
"

SendMessage.cs
"
using GecolPro.Models.Models;
using GecolPro.Services.IServices;
using GecolPro.WebApi.Interfaces;
using Newtonsoft.Json;

namespace GecolPro.WebApi.BusinessRules
{
    public class SendMessage : ISendMessage

    {
        private ILoggers _loggerG;

        /* Send SMS API to SMPP Client  :*/


        public SendMessage(ILoggers loggerG)
        {
            _loggerG = loggerG;

        }

        public  async Task SendGecolMessage(string? sender, string receiver, string message, string ConversationID)
        {
            try
            {

                if (!string.IsNullOrEmpty(message))
                {
                    var client = new HttpClient();
                    var request = new HttpRequestMessage(HttpMethod.Post, "http://172.16.31.17:8086/api/Messages");

                    SmsMessage jsonObject = new SmsMessage()
                    {
                        Sender = "2188997772",
                        Receiver = receiver,
                        Message = message
                    };


                    var content = new StringContent(JsonConvert.SerializeObject(jsonObject), null, "application/json");
                    request.Content = content;
                    var response = await client.SendAsync(request);

                    await _loggerG.LogInfoAsync($"LynaGclsys|==>|Req_SMSCSystem|Submet|To|{receiver}");

                    response.EnsureSuccessStatusCode();
                    var messageResponse = await response.Content.ReadAsStringAsync();

                    await _loggerG.LogInfoAsync($"LynaGclsys|<==|Rsp_SMSCSystem|Respon|{messageResponse}");
                }
            }
            catch (Exception ex)
            {
                await ExceptionLogs(ex, ConversationID);
            }
        }

        private async Task ExceptionLogs(Exception ex, string ConversationID)
        {
            await _loggerG.LogDebugAsync(
                  $"excp" +
                  $"\n{ConversationID}|{ex.Message}" +
                  $"\n{ConversationID}|{ex.InnerException}" +
                  $"\n{ConversationID}|{ex.StackTrace.ToString()}"
                  );
        }


    }

  
}

"

Menus.cs
"
using GecolPro.Models.Models;
using GecolPro.WebApi.Interfaces;
namespace GecolPro.WebApi.BusinessRules
{
    public class Menus : IMenus
    {

        public Menus() 
        { 
        
        }

        private  MsgContent msgContent = new MsgContent();

        public  async Task<MsgContent> SuccessResponseAsync(List<string> Arg, string Lang)
        {
            switch (Lang)
            {
                case "En":
                    msgContent.UssdCont = string.Format("The Meter: {0}\nCharged Amount: {1} LYD\n the Token : {2}\nSupportKey : {3}", Arg[0], Arg[1], Arg[2], Arg[3]);

                    msgContent.MessageCont = string.Format("The Meter: {0}, Charged by  {1} LYD \n the Token :  {2} \n tKey :  {3}", Arg[0], Arg[1], Arg[2], Arg[3]);

                    break;

                default:

                    msgContent.UssdCont = string.Format("رقم العداد {0}\nالقيمة المشحونة {1}  دينار\nكرت {2}\n رقم عملية الشحن  {3}", Arg[0], Arg[1], Arg[2], Arg[3]); ;

                    msgContent.MessageCont = string.Format("تم شحن العداد {0} بي {1} دينار \n  كرت الشحن  {2} \n   رقم عملية الشحن  {3}", Arg[0], Arg[1], Arg[2], Arg[3]);

                    break;
            }
            return (msgContent);
        }


        public  async Task<MsgContent> BlockedResponseAsync(string Lang)
        {

            switch (Lang)
            {
                case "En":
                    msgContent.UssdCont = string.Format("The Servise not allow for your number.");

                    break;

                default:

                    msgContent.UssdCont = string.Format("الخدمة غير متاحة لرقمك."); ;

                    break;
            }
            return (msgContent);
        }

        public  async Task<MsgContent> BlockedResponseAsync(string FaultCode, string Lang)
        {

            switch (Lang)
            {
                case "En":
                    msgContent.UssdCont = string.Format("The Servise not allow for your number.");

                    break;

                default:

                    msgContent.UssdCont = string.Format("الخدمة غير متاحة لرقمك."); ;

                    break;
            }
            return (msgContent);
        }

        //public static async Task<MsgContent> MeterNotExist(string Arg ,string Lang)
        //{
        //    string ussdCont;

        //    //string messageCont = null;

        //    switch (Lang)
        //    {
        //        case "En":
        //            msgContent.UssdCont = string.Format("The Meter: {0} Not right or not exist", Arg);

        //            break;

        //        default:

        //            msgContent.UssdCont = string.Format("رقم العداد {0} غير صحيح او غير موجود.", Arg); ;

        //            break;
        //    }
        //    //return (ussdCont, messageCont);
        //    return msgContent;
        //}

        public  async Task<MsgContent> UnderMaintenance_Gecol(string FaultCode, string Lang)
        {
            switch (Lang)
            {
                case "En":

                    switch (FaultCode)
                    {
 

                        case "caseFree1":
                            msgContent.UssdCont = string.Format("The service under maintenance.");

                            break;

                        case "caseFree2":
                            msgContent.UssdCont = string.Format("The service under maintenance.");

                            break;

                        case "caseFree3":
                            msgContent.UssdCont = string.Format("The service under maintenance.");

                            break;

                        case "VD.13020116":
                            msgContent.UssdCont = string.Format("The service under maintenance,Issue with Amount Value");

                            break;

                        case "timeout":
                            msgContent.UssdCont = string.Format("The service timeouted.");

                            break;

                        case "VD.01010018":
                            msgContent.UssdCont = string.Format("Customer does not exist or unbound meter");

                            break;

                        default:

                            msgContent.UssdCont = string.Format("The service under maintenance.");

                            break;
                    }
                    break;

                default:
                    switch (FaultCode)
                    {

                        case "caseFree1":
                            msgContent.UssdCont = string.Format("الخدمة تحت الصيانة");

                            break;

                        case "caseFree2":
                            msgContent.UssdCont = string.Format("الخدمة تحت الصيانة");

                            break;
                        case "caseFree3":
                            msgContent.UssdCont = string.Format("الخدمة تحت الصيانة");

                            break;

                        case "VD.13020116":
                            msgContent.UssdCont = string.Format("الخدمة تحت الصيانة,مشكلة في قيمة الرصيد.");

                            break;

                        case "timeout":
                            msgContent.UssdCont = string.Format("مهلة الاتصال انتهت");

                            break;

                        case "VD.01010018":
                            msgContent.UssdCont = string.Format("رقم العداد غير صحيح او غير موجود.");

                            break;

                        default:
                            msgContent.UssdCont = string.Format("الخدمة تحت الصيانة");

                            break;
                    }
                    break;

            }

            return msgContent;
        }

        public  async Task<MsgContent> UnderMaintenance_Billing(string FaultCode, string Lang)
        {


            switch (Lang)
            {
                case "En":
                    switch (FaultCode)
                    {

                        case "ns1:S-WS-00045":
                            msgContent.UssdCont = string.Format("The Billing system under maintenance.");

                            break;

                        case "S-ACT-00112":
                            msgContent.UssdCont = string.Format("Not sufficient balance.");

                            break;

                        case "caseFree1":
                            msgContent.UssdCont = string.Format("The Billing system under maintenance.");

                            break;

                        case "caseFree2":
                            msgContent.UssdCont = string.Format("The Billing system under maintenance.");

                            break;

                        default:

                            msgContent.UssdCont = string.Format("The Billing system under maintenance.");

                            break;
                    }
                    break;
                
                default:
                    switch (FaultCode)
                    {
                        case "ns1:S-WS-00045":
                            msgContent.UssdCont = string.Format("نظام الفوترة تحت الصيانة");

                            break;

                        case "S-ACT-00112":
                            msgContent.UssdCont = string.Format("رصيدك غير كافي.");

                            break;

                        case "caseFree1":
                            msgContent.UssdCont = string.Format("نظام الفوترة تحت الصيانة");

                            break;

                        case "caseFree2":
                            msgContent.UssdCont = string.Format("نظام الفوترة تحت الصيانة");



                            break;

                        default:

                            msgContent.UssdCont = string.Format("نظام الفوترة تحت الصيانة");

                            break;
                    }
                    break;
            }

            return msgContent;
        }
    }
}


"

BlackListFun.cs
"
using GecolPro.WebApi.Interfaces;
using Newtonsoft.Json;

namespace GecolPro.WebApi.BusinessRules
{
    public class BlackListFun : IBlackListFun
    {
        private readonly string jsonFilePath;

        public BlackListFun()
        {
            string baseDirectory = AppDomain.CurrentDomain.BaseDirectory;
            jsonFilePath = Path.Combine(baseDirectory, "BlackListMsisdn.json");
        }

        public async Task SyncBlackList(List<string> blackMsisdnList)
        {
            try
            {

                if (blackMsisdnList == null || blackMsisdnList.Count == 0)
                {
                    //return BadRequest("Invalid phone numbers list.");
                }

                List<string> blackList = new List<string>();

                if (System.IO.File.Exists(jsonFilePath))
                {
                    var json = await System.IO.File.ReadAllTextAsync(jsonFilePath);
                    blackList = JsonConvert.DeserializeObject<List<string>>(json) ?? new List<string>();
                }

                foreach (var newNumber in blackMsisdnList)
                {
                    if (!blackList.Exists(number => newNumber.StartsWith(number)))
                    {
                        blackList.Add(newNumber);
                    }
                }

                var updatedJson = JsonConvert.SerializeObject(blackList, Formatting.Indented);
                await System.IO.File.WriteAllTextAsync(jsonFilePath, updatedJson);
            }
            catch (Exception ex)
            {
                string message = ex.Message;

            }
        }

        public async Task<List<string>> GetBlackList()
        {

            if (!System.IO.File.Exists(jsonFilePath))
            {
                return new List<string>();
            }

            var json = await System.IO.File.ReadAllTextAsync(jsonFilePath);
            var blackList = JsonConvert.DeserializeObject<List<string>>(json) ?? new List<string>();

            return blackList;
        }


        public async Task SyncDeleteBlackList(string phoneNumber)
        {
            string res;
            try
            {
                if (string.IsNullOrWhiteSpace(phoneNumber))
                {
                    res = "Invalid phone number.";
                }

                if (!System.IO.File.Exists(jsonFilePath))
                {
                    res = "Blacklist not found.";
                }

                var json = await System.IO.File.ReadAllTextAsync(jsonFilePath);
                var blacklist = JsonConvert.DeserializeObject<List<string>>(json) ?? new List<string>();

                if (!blacklist.Remove(phoneNumber))
                {

                    res = "Phone number not found in the blacklist.";
                }

                var updatedJson = JsonConvert.SerializeObject(blacklist, Formatting.Indented);
                await System.IO.File.WriteAllTextAsync(jsonFilePath, updatedJson);
            }
            catch (Exception ex)
            {
                string message = ex.Message;

            }
        }


    }
}

"